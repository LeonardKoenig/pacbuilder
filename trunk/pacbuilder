#!/bin/bash
# PacBuilder
# By Andrea Cimitan

# BEGIN_SECTION - environment checks

function check_uid()
{
	if [ $UID != 0 ]; then
		printf "$COMMAND_NAME requires root permissions to run\n"
		exit
	fi
}

function colorize_output()
{
	if [ "$NO_COLOR" != "TRUE" ]; then
		COLOR_0M="\033[1;0m"
		COLOR_1M="\033[1;1m"
		COLOR_31M="\033[1;31m"
		COLOR_32M="\033[1;32m"
		COLOR_33M="\033[1;33m"
		COLOR_34M="\033[1;34m"
	fi
}

function environment()
{
	AUTHOR_NAME="Andrea Cimitan"
	AUTHOR_EMAIL="andrea.cimitan@gmail.com"
	COMMAND_BIN="pacbuilder"
	COMMAND_NAME="PacBuilder"
	LICENSE="GPLv3"
	TMP_PATH=/tmp/${COMMAND_BIN}/build
	LOG_FILE_PACKAGES=/var/log/${COMMAND_BIN}-packages.log
	ABS_REPOS_URL="http://repos.archlinux.org/viewvc.cgi"
	SYNCCMD="rsync"
	SYNCARGS="-mrtv --no-motd --delete-after --delete-excluded"
	SYNCSERVER="rsync.archlinux.org"

	mkdir -p ${TMP_PATH}
}

# END_SECTION - environment checks
# BEGIN_SECTION - command line options

function add_repository()
{
	ALREADY_ADDED="FALSE"
	for ADDED_REPOSITORY in $TARGET_REPOSITORY; do
		if [ "$ADDED_REPOSITORY" == "$1" ]; then
			ALREADY_ADDED="TRUE"
		fi
	done
	if [ "$ALREADY_ADDED" != "TRUE" ]; then
		TARGET_REPOSITORY=${TARGET_REPOSITORY}$1" "
		REPOSITORY_ENABLED="TRUE"
	fi
}

function add_type()
{
	ALREADY_ADDED="FALSE"
	for ADDED_TYPE in $ENABLED_TYPES; do
		if [ "$ADDED_TYPE" == "$1" ]; then
			ALREADY_ADDED="TRUE"
		fi
	done
	if [ "$ALREADY_ADDED" != "TRUE" ]; then
		ENABLED_TYPES=${ENABLED_TYPES}$1" "
		TYPES_ENABLED="TRUE"
	fi
}

function check_args()
{
	if [ -z "$1" ]; then
		NO_COLOR="TRUE"
		print_help
		exit
	fi
	for EXTRA_FLAG in $@; do
		if [ "$EXTRA_FLAG" == "--nocolor" ]; then
			NO_COLOR="TRUE"
		fi
	done
	for EXTRA_FLAG in $@; do
		case $EXTRA_FLAG in
			--core) add_repository "core" ;;
			--extra) add_repository "extra" ;;
			--testing) add_repository "testing" ;;
			--unstable) add_repository "unstable" ;;
			--community) add_repository "community" ;;
			--aur) add_repository "aur" ;;
		esac
	done
	for EXTRA_FLAG in $@; do
		case $EXTRA_FLAG in
			-h) print_help; exit ;;
			--help) print_help; exit ;;
			--verbose) VERBOSE="TRUE" ;;
			--edit) VERBOSE="TRUE"; EDIT_PKGBUILD="TRUE" ;;
			--gccinfo) print_gcc_info ;;
			--clean) clean ;;
			--sysupgrade) SYSUPGRADE="TRUE" ;;
			--upgrade) SYSUPGRADE="TRUE" ;;
			--deps) add_type "deps" ;;
			--explicit) add_type "explicit" ;;
			--world) add_type "world" ;;
		esac
	done
}

# END_SECTION - command line options
# BEGIN_SECTION - print to stdout

function print_help()
{
	printf "A tool to massively recompile packages from sources\n"
	printf "It currently fetches both ABS and AUR\n"
	printf "\n"
	printf "USAGE:\n"
	printf "  $COMMAND_BIN --option1 --option2 --option3 ...\n"
	printf "\n"
	printf "OPTIONS:\n"
	printf "  General:\n"
	printf "    --help       print this help\n"
	printf "    --clean      remove previous log\n"
	printf "    --edit       be verbose and edit PKGBUILD\n"
	printf "    --gccinfo    print current compilation flags\n"
	printf "    --nocolor    don't use any color\n"
	printf "    --verbose    print makepkg output\n"
	printf "  Target type:\n"
	printf "    --deps       recompile deps\n"
	printf "    --explicit   recompile explicitely installed packages\n"
	printf "    --world      recompile both deps and explicit\n"
	printf "  Target repository:\n"
	printf "    --core       recompile packages in core\n"
	printf "    --extra      recompile packages in extra\n"
	printf "    --testing    recompile packages in testing\n"
	printf "    --unstable   recompile packages in unstable\n"
	printf "    --community  recompile packages in community\n"
	printf "    --aur        recompile packages in aur\n"
	printf "  Other operations:\n"
	printf "    --upgrade    build the updated packages\n"
}

function print_gcc_info()
{
	source /etc/makepkg.conf

	printf "${COLOR_1M}Carch:${COLOR_0M} ${CARCH}\n"
	printf "${COLOR_1M}Chost:${COLOR_0M} ${CHOST}\n"
	printf "${COLOR_1M}Cflags:${COLOR_0M} ${CFLAGS}\n"
	printf "${COLOR_1M}Cxxflags:${COLOR_0M} ${CXXFLAGS}\n"
	printf "\n"
}

function print_repo()
{
	printf "${COLOR_1M}Repo:${COLOR_0M} $1\n"
}

function print_title()
{
	if [ "$NO_COLOR" != "TRUE" ]; then
		printf "${COLOR_34M}-------------------------------\n"
		printf "${COLOR_33M} $COMMAND_NAME${COLOR_0M}, by $AUTHOR_NAME ${COLOR_34M}\n"
		printf "${COLOR_34M}-------------------------------\n"
		printf "${COLOR_0M}\n"
	else
		printf "\033[1;0m-------------------------------\n"
		printf " $COMMAND_NAME, by $AUTHOR_NAME\n"
		printf "\033[1;0m-------------------------------\n"
		printf "\n"
	fi
}

function print_type()
{
	printf "${COLOR_1M}Type:${COLOR_0M} $1\n"
}

# END_SECTION - print to stdout
# BEGIN_SECTION - pkgbuild parsing and editing

function add_carch()
{
	unset arch
	source ./PKGBUILD &> /dev/null
	if [ -z "$arch" ]; then
		source /etc/makepkg.conf
		[ -z "$CARCH" ] && CARCH="i686"
		sed -i "/^build/iarch=('$CARCH')\n" ./PKGBUILD &> /dev/null
	fi
}

function edit_pkgbuild()
{
	if [ "$VERBOSE" == "TRUE" ]; then
		printf "\n"
		if [ "$EDIT_PKGBUILD" == "TRUE" ]; then
			if [ -f ./PKGBUILD ]; then
				printf "${COLOR_33M}==> EDIT PKGBUILD:${COLOR_0M}"
				printf "${COLOR_1M} Do you want to edit this PKGBUILD? (yes/no): ${COLOR_0M}"
				read EDIT_ANSWER
				if [ "$EDIT_ANSWER" != "no" ]; then
					[ -z "$EDITOR" ] && EDITOR=nano
					$EDITOR ./PKGBUILD
				fi
			fi
		fi
	fi
}

function get_community_category()
{
	AUR_ID=`wget -q -O - "http://aur.archlinux.org/rpc.php?type=info&arg=${1}" \
	        | sed -e 's/^.*{"ID":"//' -e 's/",".*$//' | sed '/^$/d'`
	CATEGORY=`wget -q "http://aur.archlinux.org/packages.php?ID=${AUR_ID}" -O - \
	          | grep 'community ::' | sed 's|<[^<]*>||g' | awk '{print $3}'`
	echo $CATEGORY
}

function get_pkgbuild()
{
	REPOSITORY=`LANG=C pacman -Si ${1} 2> /dev/null | grep -m1 Repository | awk -F": " '{ print $2 }'`
	case $REPOSITORY in
		core) ;;
		extra) ;;
		testing) ;;
		unstable) ;;
		community) REPOSITORY=${REPOSITORY}/`get_community_category ${1}` ;;
		*) REPOSITORY="aur" ;;
	esac
	if [ "$REPOSITORY" != "aur" ]; then
		$SYNCCMD $SYNCARGS ${SYNCSERVER}::abs/${CARCH}/${REPOSITORY}/${1} ${TMP_PATH}
		if [ ! -e ${TMP_PATH}/${1}/PKGBUILD ]; then
			REPOSITORY="aur"
		fi
	fi
	if [ "$REPOSITORY" == "aur" ]; then
		cd ${TMP_PATH}
		wget http://aur.archlinux.org/packages/${1}/${1}.tar.gz
		tar xfz ./${1}.tar.gz
		rm -rf ./${1}.tar.gz
	fi
	cd ${TMP_PATH}/${1}
}

function get_pkginfo()
{
	unset arch pkgname pkgver pkgrel
	source ./PKGBUILD &> /dev/null
	source /etc/makepkg.conf
	[ -z "$CARCH" ] && CARCH="i686"
	arch=$CARCH
}

# END_SECTION - pkgbuild parsing and editing
# BEGIN_SECTION - manage package installation

function build_type()
{
	if [ "$TARGET_REPOSITORY" != "" ]; then
		print_repo "$TARGET_REPOSITORY\n"
		printf "Fetching repositories, this may take a long time..."
		match_repository $PACKAGES
		printf "${COLOR_32M} done!${COLOR_0M}\n"
		printf "\n"
	else
		print_repo "build from every repository\n"
	fi
	build_multiple_packages
}

function build_multiple_packages()
{
	rm -rf ${TMP_PATH}/* &> /dev/null
	check_log_file
	sed -i '/^$/d' ${LOG_FILE_PACKAGES}
	PACKAGES=`cat ${LOG_FILE_PACKAGES}`
	NUM_PACKAGES=`cat ${LOG_FILE_PACKAGES} | wc -l`
	ERROR_PACKAGES=""
	CURRENT_INDEX=1
	for CURRENT_PACKAGE in $PACKAGES; do
		printf "${COLOR_32M}==>${COLOR_0M}"
		printf "${COLOR_1M} Building ${CURRENT_PACKAGE}"
		printf "${COLOR_0M} [package $CURRENT_INDEX of $NUM_PACKAGES] ..."
		if [ "`pacman -Qd $CURRENT_PACKAGE | awk -F" " '{print $1}'`" != "" ]; then
			EXTRA_PACMAN_OPTIONS="--asdeps"
		fi
		get_pkgbuild ${CURRENT_PACKAGE} &> /dev/null
		if [ -f ${TMP_PATH}/${CURRENT_PACKAGE}/PKGBUILD ]; then
			add_carch
			edit_pkgbuild
			get_pkginfo
			if [ "$VERBOSE" != "TRUE" ]; then
				makepkg --asroot --noconfirm &> /dev/null
			else
				if [ "$NO_COLOR" != "TRUE" ]; then
					makepkg --asroot --noconfirm
				else
					makepkg --asroot --noconfirm --nocolor
				fi
				printf "${COLOR_32M}==>${COLOR_0M}"
				printf "${COLOR_1M} Installing $pkgname-$pkgver-$pkgrel-$arch.pkg.tar.gz"
				printf "${COLOR_0M} [package $CURRENT_INDEX of $NUM_PACKAGES] ..."
			fi
			pacman -U --noconfirm $EXTRA_PACMAN_OPTIONS $pkgname-$pkgver-$pkgrel-$arch.pkg.tar.gz &> /dev/null
			CHECK_INSTALL=`grep upgraded /var/log/pacman.log | tail -n1 /var/log/pacman.log | grep $CURRENT_PACKAGE | wc -l`
		else
			CHECK_INSTALL="0"
		fi
		if [ "$CHECK_INSTALL" == "1" ]; then
			rm -rf ${TMP_PATH}/${CURRENT_PACKAGE} &> /dev/null
			sed -i '/'${CURRENT_PACKAGE}'/d' ${LOG_FILE_PACKAGES}
			printf "${COLOR_32M} installed!${COLOR_0M}\n"
		else
			ERROR_PACKAGES=${ERROR_PACKAGES}$CURRENT_PACKAGE" "
			printf "${COLOR_31M} error!${COLOR_0M}\n"
		fi
		(( CURRENT_INDEX++ ))
	done
	if [ "$ERROR_PACKAGES" != "" ]; then
		printf "${COLOR_31M}==> ERROR:${COLOR_0M}"
		printf "${COLOR_1M} I was unable to install these packages:${COLOR_0M} $ERROR_PACKAGES\n"
	else
		delete_log
	fi
}

function check_log_file()
{
	if [ ! -e ${LOG_FILE_PACKAGES} ]; then
		printf "${COLOR_31M}==> ERROR:${COLOR_0M}"
		printf "${COLOR_1M} I was unable to find any package to build...";
		printf "${COLOR_31M} exiting!${COLOR_0M}\n"
		exit
	fi
}

function clean()
{
	printf "${COLOR_33M}==> WARNING:${COLOR_0M}"
	printf "${COLOR_1M} Do you want to delete your previous build log?\n"
	printf "You will not be able to resume it in the future. Are you sure? (no/yes): ${COLOR_0M}"
	read DELETE_ANSWER
	printf "\n"
	if [ "$DELETE_ANSWER" == "yes" ]; then
			delete_log
	fi
}

function delete_log()
{
	if [ -f ${LOG_FILE_PACKAGES} ]; then
		rm -rf ${LOG_FILE_PACKAGES} &> /dev/null
	fi
}

function match_repository()
{
	JOINT_PACKAGES=""
	CURRENT_INDEX=0
	for CURRENT_PACKAGE in $@; do
		REPOSITORY=`LANG=C pacman -Si $CURRENT_PACKAGE 2> /dev/null | grep -m1 Repository | awk -F": " '{ print $2 }'`
		case $REPOSITORY in
			core) ;;
			extra) ;;
			testing) ;;
			unstable) ;;
			community) ;;
			*) REPOSITORY="aur" ;;
		esac
		for CURRENT_REPOSITORY in $REPOSITORY; do
			for CURRENT_TARGET_REPOSITORY in $TARGET_REPOSITORY; do
				if [ "$CURRENT_REPOSITORY" == "$CURRENT_TARGET_REPOSITORY" ]; then
					JOINT_PACKAGES=${JOINT_PACKAGES}$CURRENT_PACKAGE"\n"
				fi
			done
		done
	done
	echo -e $JOINT_PACKAGES > ${LOG_FILE_PACKAGES}
	sed -i '/^$/d' ${LOG_FILE_PACKAGES}
	PACKAGES=`cat ${LOG_FILE_PACKAGES}`
}

# END_SECTION - select packages
# BEGIN_SECTION - start building by type

function read_type()
{
	if [ "$TYPES_ENABLED" == "" ] && [ "$REPOSITORY_ENABLED" != "" ]; then
		printf "No type specified, assuming world...\n\n"
		ENABLED_TYPES="world"
		sleep 1
	elif [ "$TYPES_ENABLED" != "" ] && [ "$REPOSITORY_ENABLED" == "" ]; then
		printf "No repository specified, build all...\n\n"
		sleep 1
	fi
	for EXTRA_TYPE in $ENABLED_TYPES; do
		case $EXTRA_TYPE in
			deps) type_deps ;;
			explicit) type_explicit ;;
			world) type_world ;;
		esac
	done
}

function resume()
{
	if [ -f ${LOG_FILE_PACKAGES} ]; then
		printf "${COLOR_33M}==> ATTENTION:${COLOR_0M}"
		printf "${COLOR_1M} Previous build detected. Do you want to resume? (yes/no):${COLOR_0M} "
		read RESUME_ANSWER
		if [ "$RESUME_ANSWER" != "no" ]; then
			printf "\n"
			printf "Resuming...\n"
			build_multiple_packages
			exit
		else
			printf "${COLOR_33M}==> ATTENTION:${COLOR_0M}"
			printf "${COLOR_1M} Your previous build will be overwritten. Continue? (no/yes):${COLOR_0M} "
			read RESUME_ANSWER
			printf "\n"
			if [ "$RESUME_ANSWER" != "yes" ]; then
				printf "Exiting...\n"
				exit
			fi
		fi
	fi
}

function sysupgrade()
{
	if [ "$SYSUPGRADE" == "TRUE" ]; then
		printf "Refreshing pacman database, please wait..."
		PACKAGES=(`pacman --sync --refresh --sysupgrade --print-uris \
		           | grep "^\(ftp:\/\/\|http:\/\/\|file:\/\/\)" \
		           | sed -e "s/-i686.pkg.tar.gz$//" \
		                 -e "s/-x86_64.pkg.tar.gz$//" \
		                 -e "s/-any.pkg.tar.gz$//" \
		                 -e "s/.pkg.tar.gz//" \
		                 -e "s/^.*\///" \
		                 -e "s/-[^-]*-[^-]*$//" \
		           | sort --reverse`)
		for PACKAGE in ${PACKAGES[@]}; do
			UPGRADABLE_PACKAGES=${UPGRADABLE_PACKAGES}$PACKAGE"\n"
		done
		echo -e $UPGRADABLE_PACKAGES > ${LOG_FILE_PACKAGES}
		sed -i '/^$/d' ${LOG_FILE_PACKAGES}
		PACKAGES=`cat ${LOG_FILE_PACKAGES}`
		TYPES_ENABLED="TRUE"
		printf "${COLOR_32M} done!${COLOR_0M}\n"
		printf "\n"
		print_type "both deps and explicit packages"
		build_type
		exit
	fi
}

function type_deps()
{
	pacman -Qd | awk -F" " '{print $1}' > ${LOG_FILE_PACKAGES}
	PACKAGES=`pacman -Qd | awk -F" " '{print $1}'`
	if [ "$DONE_DEPS" != "TRUE" ]; then
		print_type "deps packages"
		build_type
	fi
	DONE_DEPS="TRUE"
}

function type_explicit()
{
	pacman -Qe | awk -F" " '{print $1}' > ${LOG_FILE_PACKAGES}
	PACKAGES=`pacman -Qe | awk -F" " '{print $1}'`
	EXTRA_YAOURT_OPTIONS=""
	if [ "$DONE_EXPLICIT" != "TRUE" ]; then
		print_type "explicit packages"
		build_type
	fi
	DONE_EXPLICIT="TRUE"
}

function type_world()
{
	pacman -Q | awk -F" " '{print $1}' > ${LOG_FILE_PACKAGES}
	PACKAGES=`pacman -Q | awk -F" " '{print $1}'`
	if [ "$DONE_WORLD" != "TRUE" ]; then
		print_type "both deps and explicit packages"
		build_type
	fi
	DONE_DEPS="TRUE"
	DONE_EXPLICIT="TRUE"
	DONE_WORLD="TRUE"
}

# END_SECTION - select packages
# BEGIN_SECTION - application run

function main()
{
	environment
	check_uid
	check_args $@
	colorize_output
	print_title
	resume
	sysupgrade
	read_type
}

main $@

# END_SECTION - application run
